{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Linker = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nclass Linker {\n  constructor(container) {\n    this.container = container;\n  }\n\n  isEnabled(particle) {\n    return particle.particlesOptions.links.enable;\n  }\n\n  reset() {}\n\n  interact(p1) {\n    var _a;\n\n    const container = this.container;\n    const linkOpt1 = p1.particlesOptions.links;\n    const optOpacity = linkOpt1.opacity;\n    const optDistance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;\n    const canvasSize = container.canvas.size;\n    const warp = linkOpt1.warp;\n    const pos1 = p1.getPosition();\n    const range = warp ? new Utils_1.CircleWarp(pos1.x, pos1.y, optDistance, canvasSize) : new Utils_1.Circle(pos1.x, pos1.y, optDistance);\n    const query = container.particles.quadTree.query(range);\n\n    for (const p2 of query) {\n      const linkOpt2 = p2.particlesOptions.links;\n\n      if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed) {\n        continue;\n      }\n\n      const pos2 = p2.getPosition();\n      let distance = Utils_1.NumberUtils.getDistance(pos1, pos2);\n\n      if (warp) {\n        if (distance > optDistance) {\n          const pos2NE = {\n            x: pos2.x - canvasSize.width,\n            y: pos2.y\n          };\n          distance = Utils_1.NumberUtils.getDistance(pos1, pos2NE);\n\n          if (distance > optDistance) {\n            const pos2SE = {\n              x: pos2.x - canvasSize.width,\n              y: pos2.y - canvasSize.height\n            };\n            distance = Utils_1.NumberUtils.getDistance(pos1, pos2SE);\n\n            if (distance > optDistance) {\n              const pos2SW = {\n                x: pos2.x,\n                y: pos2.y - canvasSize.height\n              };\n              distance = Utils_1.NumberUtils.getDistance(pos1, pos2SW);\n            }\n          }\n        }\n      }\n\n      if (distance > optDistance) {\n        return;\n      }\n\n      const opacityLine = (1 - distance / optDistance) * optOpacity;\n      const linksOptions = p1.particlesOptions.links;\n      let linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n\n      if (!linkColor) {\n        const optColor = linksOptions.color;\n        linkColor = Utils_1.ColorUtils.getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n\n        if (linksOptions.id !== undefined) {\n          container.particles.linksColors.set(linksOptions.id, linkColor);\n        } else {\n          container.particles.linksColor = linkColor;\n        }\n      }\n\n      if (p2.links.map(t => t.destination).indexOf(p1) === -1 && p1.links.map(t => t.destination).indexOf(p2) === -1) {\n        p1.links.push({\n          destination: p2,\n          opacity: opacityLine\n        });\n      }\n    }\n  }\n\n}\n\nexports.Linker = Linker;","map":null,"metadata":{},"sourceType":"script"}