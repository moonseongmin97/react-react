{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nconst OutModeDirection_1 = require(\"../../Enums/Directions/OutModeDirection\");\n\nfunction bounceHorizontal(data) {\n  if (data.outMode === Enums_1.OutMode.bounce || data.outMode === Enums_1.OutMode.bounceHorizontal || data.outMode === \"bounceHorizontal\") {\n    const velocity = data.particle.velocity.horizontal;\n    let bounced = false;\n\n    if (data.direction === OutModeDirection_1.OutModeDirection.right && data.bounds.right >= data.canvasSize.width && velocity > 0 || data.direction === OutModeDirection_1.OutModeDirection.left && data.bounds.left <= 0 && velocity < 0) {\n      const newVelocity = Utils_1.NumberUtils.getValue(data.particle.particlesOptions.bounce.horizontal);\n      data.particle.velocity.horizontal *= -newVelocity;\n      bounced = true;\n    }\n\n    if (bounced) {\n      const minPos = data.offset.x + data.size;\n\n      if (data.bounds.right >= data.canvasSize.width) {\n        data.particle.position.x = data.canvasSize.width - minPos;\n      } else if (data.bounds.left <= 0) {\n        data.particle.position.x = minPos;\n      }\n    }\n  }\n}\n\nfunction bounceVertical(data) {\n  if (data.outMode === Enums_1.OutMode.bounce || data.outMode === Enums_1.OutMode.bounceVertical || data.outMode === \"bounceVertical\") {\n    const velocity = data.particle.velocity.vertical;\n    let bounced = false;\n\n    if (data.direction === OutModeDirection_1.OutModeDirection.bottom && data.bounds.bottom >= data.canvasSize.height && velocity > 0 || data.direction === OutModeDirection_1.OutModeDirection.top && data.bounds.top <= 0 && velocity < 0) {\n      const newVelocity = Utils_1.NumberUtils.getValue(data.particle.particlesOptions.bounce.vertical);\n      data.particle.velocity.vertical *= -newVelocity;\n      bounced = true;\n    }\n\n    if (bounced) {\n      const minPos = data.offset.y + data.size;\n\n      if (data.bounds.bottom >= data.canvasSize.height) {\n        data.particle.position.y = data.canvasSize.height - minPos;\n      } else if (data.bounds.top <= 0) {\n        data.particle.position.y = minPos;\n      }\n    }\n  }\n}\n\nfunction checkDestroy(particle, destroy, value, minValue, maxValue) {\n  switch (destroy) {\n    case Enums_1.DestroyType.max:\n      if (value >= maxValue) {\n        particle.destroy();\n      }\n\n      break;\n\n    case Enums_1.DestroyType.min:\n      if (value <= minValue) {\n        particle.destroy();\n      }\n\n      break;\n  }\n}\n\nclass Updater {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n  }\n\n  update(delta) {\n    if (this.particle.destroyed) {\n      return;\n    }\n\n    this.updateLife(delta);\n\n    if (this.particle.destroyed || this.particle.spawning) {\n      return;\n    }\n\n    this.updateOpacity(delta);\n    this.updateSize(delta);\n    this.updateAngle(delta);\n    this.updateColor(delta);\n    this.updateStrokeColor(delta);\n    this.updateOutModes(delta);\n  }\n\n  updateLife(delta) {\n    const particle = this.particle;\n    let justSpawned = false;\n\n    if (particle.spawning) {\n      particle.lifeDelayTime += delta.value;\n\n      if (particle.lifeDelayTime >= particle.lifeDelay) {\n        justSpawned = true;\n        particle.spawning = false;\n        particle.lifeDelayTime = 0;\n        particle.lifeTime = 0;\n      }\n    }\n\n    if (particle.lifeDuration === -1) {\n      return;\n    }\n\n    if (!particle.spawning) {\n      if (justSpawned) {\n        particle.lifeTime = 0;\n      } else {\n        particle.lifeTime += delta.value;\n      }\n\n      if (particle.lifeTime >= particle.lifeDuration) {\n        particle.lifeTime = 0;\n\n        if (particle.livesRemaining > 0) {\n          particle.livesRemaining--;\n        }\n\n        if (particle.livesRemaining === 0) {\n          particle.destroy();\n          return;\n        }\n\n        const canvasSize = this.container.canvas.size;\n        particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);\n        particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);\n        particle.spawning = true;\n        particle.lifeDelayTime = 0;\n        particle.lifeTime = 0;\n        const lifeOptions = particle.particlesOptions.life;\n        particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;\n        particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;\n      }\n    }\n  }\n\n  updateOpacity(delta) {\n    var _a, _b;\n\n    const particle = this.particle;\n    const opacityAnim = particle.particlesOptions.opacity.anim;\n    const minValue = opacityAnim.minimumValue;\n    const maxValue = particle.particlesOptions.opacity.value;\n\n    if (opacityAnim.enable) {\n      switch (particle.opacity.status) {\n        case Enums_1.AnimationStatus.increasing:\n          if (particle.opacity.value >= maxValue) {\n            particle.opacity.status = Enums_1.AnimationStatus.decreasing;\n          } else {\n            particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.AnimationStatus.decreasing:\n          if (particle.opacity.value <= minValue) {\n            particle.opacity.status = Enums_1.AnimationStatus.increasing;\n          } else {\n            particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n          }\n\n          break;\n      }\n\n      checkDestroy(particle, opacityAnim.destroy, particle.opacity.value, minValue, maxValue);\n\n      if (!particle.destroyed) {\n        particle.opacity.value = Utils_1.NumberUtils.clamp(particle.opacity.value, minValue, maxValue);\n      }\n    }\n  }\n\n  updateSize(delta) {\n    var _a, _b;\n\n    const container = this.container;\n    const particle = this.particle;\n    const sizeOpt = particle.particlesOptions.size;\n    const sizeAnim = sizeOpt.animation;\n    const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n    const maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n    const minValue = sizeAnim.minimumValue * container.retina.pixelRatio;\n\n    if (sizeAnim.enable) {\n      switch (particle.size.status) {\n        case Enums_1.AnimationStatus.increasing:\n          if (particle.size.value >= maxValue) {\n            particle.size.status = Enums_1.AnimationStatus.decreasing;\n          } else {\n            particle.size.value += sizeVelocity;\n          }\n\n          break;\n\n        case Enums_1.AnimationStatus.decreasing:\n          if (particle.size.value <= minValue) {\n            particle.size.status = Enums_1.AnimationStatus.increasing;\n          } else {\n            particle.size.value -= sizeVelocity;\n          }\n\n      }\n\n      checkDestroy(particle, sizeAnim.destroy, particle.size.value, minValue, maxValue);\n\n      if (!particle.destroyed) {\n        particle.size.value = Utils_1.NumberUtils.clamp(particle.size.value, minValue, maxValue);\n      }\n    }\n  }\n\n  updateAngle(delta) {\n    var _a;\n\n    const particle = this.particle;\n    const rotate = particle.particlesOptions.rotate;\n    const rotateAnimation = rotate.animation;\n    const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n    const max = 2 * Math.PI;\n\n    if (rotate.path) {\n      particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n    } else if (rotateAnimation.enable) {\n      switch (particle.rotate.status) {\n        case Enums_1.AnimationStatus.increasing:\n          particle.rotate.value += speed;\n\n          if (particle.rotate.value > max) {\n            particle.rotate.value -= max;\n          }\n\n          break;\n\n        case Enums_1.AnimationStatus.decreasing:\n        default:\n          particle.rotate.value -= speed;\n\n          if (particle.rotate.value < 0) {\n            particle.rotate.value += max;\n          }\n\n          break;\n      }\n    }\n  }\n\n  updateColor(delta) {\n    var _a;\n\n    const particle = this.particle;\n\n    if (particle.color.value === undefined) {\n      return;\n    }\n\n    if (particle.particlesOptions.color.animation.enable) {\n      particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n\n      if (particle.color.value.h > 360) {\n        particle.color.value.h -= 360;\n      }\n    }\n  }\n\n  updateStrokeColor(delta) {\n    var _a, _b;\n\n    const particle = this.particle;\n    const color = particle.stroke.color;\n\n    if (typeof color === \"string\" || color === undefined) {\n      return;\n    }\n\n    if (particle.strokeColor.value === undefined) {\n      return;\n    }\n\n    if (color.animation.enable) {\n      particle.strokeColor.value.h += ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n\n      if (particle.strokeColor.value.h > 360) {\n        particle.strokeColor.value.h -= 360;\n      }\n    }\n  }\n\n  updateOutModes(delta) {\n    var _a, _b, _c, _d;\n\n    const outModes = this.particle.particlesOptions.move.outModes;\n    this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);\n    this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);\n    this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);\n    this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);\n  }\n\n  updateOutMode(delta, outMode, direction) {\n    const container = this.container;\n    const particle = this.particle;\n\n    switch (outMode) {\n      case Enums_1.OutMode.bounce:\n      case Enums_1.OutMode.bounceVertical:\n      case Enums_1.OutMode.bounceHorizontal:\n      case \"bounceVertical\":\n      case \"bounceHorizontal\":\n        this.updateBounce(delta, direction, outMode);\n        break;\n\n      case Enums_1.OutMode.destroy:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n          container.particles.remove(particle);\n        }\n\n        break;\n\n      case Enums_1.OutMode.out:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n          this.fixOutOfCanvasPosition(direction);\n        }\n\n        break;\n\n      case Enums_1.OutMode.none:\n        this.bounceNone(direction);\n        break;\n    }\n  }\n\n  fixOutOfCanvasPosition(direction) {\n    const container = this.container;\n    const particle = this.particle;\n    const wrap = particle.particlesOptions.move.warp;\n    const canvasSize = container.canvas.size;\n    const newPos = {\n      bottom: canvasSize.height + particle.getRadius() - particle.offset.y,\n      left: -particle.getRadius() - particle.offset.x,\n      right: canvasSize.width + particle.getRadius() + particle.offset.x,\n      top: -particle.getRadius() - particle.offset.y\n    };\n    const sizeValue = particle.getRadius();\n    const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n    if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {\n      particle.position.x = newPos.left;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    } else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n      particle.position.x = newPos.right;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    }\n\n    if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.top;\n    } else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.bottom;\n    }\n  }\n\n  updateBounce(delta, direction, outMode) {\n    const container = this.container;\n    const particle = this.particle;\n    let handled = false;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta, direction);\n      }\n\n      if (handled) {\n        break;\n      }\n    }\n\n    if (handled) {\n      return;\n    }\n\n    const pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.getRadius(),\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n    bounceHorizontal({\n      particle,\n      outMode,\n      direction,\n      bounds,\n      canvasSize,\n      offset,\n      size\n    });\n    bounceVertical({\n      particle,\n      outMode,\n      direction,\n      bounds,\n      canvasSize,\n      offset,\n      size\n    });\n  }\n\n  bounceNone(direction) {\n    const particle = this.particle;\n\n    if (particle.particlesOptions.move.distance) {\n      return;\n    }\n\n    const gravityOptions = particle.particlesOptions.move.gravity;\n    const container = this.container;\n\n    if (!gravityOptions.enable) {\n      if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n        container.particles.remove(particle);\n      }\n    } else {\n      const position = particle.position;\n\n      if (gravityOptions.acceleration >= 0 && position.y > container.canvas.size.height && direction === OutModeDirection_1.OutModeDirection.bottom || gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top) {\n        container.particles.remove(particle);\n      }\n    }\n  }\n\n}\n\nexports.Updater = Updater;","map":null,"metadata":{},"sourceType":"script"}