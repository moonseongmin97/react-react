{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mover = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nclass Mover {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n  }\n\n  move(delta) {\n    const particle = this.particle;\n    particle.bubble.inRange = false;\n    particle.links = [];\n\n    for (const [, plugin] of this.container.plugins) {\n      if (particle.destroyed) {\n        break;\n      }\n\n      if (plugin.particleUpdate) {\n        plugin.particleUpdate(particle, delta);\n      }\n    }\n\n    if (particle.destroyed) {\n      return;\n    }\n\n    this.moveParticle(delta);\n    this.moveParallax();\n  }\n\n  moveParticle(delta) {\n    var _a, _b;\n\n    const particle = this.particle;\n    const particlesOptions = particle.particlesOptions;\n\n    if (!particlesOptions.move.enable) {\n      return;\n    }\n\n    const container = this.container;\n    const slowFactor = this.getProximitySpeedFactor();\n    const baseSpeed = ((_a = particle.moveSpeed) !== null && _a !== void 0 ? _a : container.retina.moveSpeed) * container.retina.reduceFactor;\n    const maxSize = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n    const sizeFactor = particlesOptions.move.size ? particle.getRadius() / maxSize : 1;\n    const moveSpeed = baseSpeed / 2 * sizeFactor * slowFactor * delta.factor;\n    this.applyNoise(delta);\n    const gravityOptions = particlesOptions.move.gravity;\n\n    if (gravityOptions.enable) {\n      particle.velocity.vertical += gravityOptions.acceleration * delta.factor / (60 * moveSpeed);\n    }\n\n    const velocity = {\n      horizontal: particle.velocity.horizontal * moveSpeed,\n      vertical: particle.velocity.vertical * moveSpeed\n    };\n\n    if (gravityOptions.enable && velocity.vertical >= gravityOptions.maxSpeed && gravityOptions.maxSpeed > 0) {\n      velocity.vertical = gravityOptions.maxSpeed;\n      particle.velocity.vertical = velocity.vertical / moveSpeed;\n    }\n\n    particle.position.x += velocity.horizontal;\n    particle.position.y += velocity.vertical;\n\n    if (particlesOptions.move.vibrate) {\n      particle.position.x += Math.sin(particle.position.x * Math.cos(particle.position.y));\n      particle.position.y += Math.cos(particle.position.y * Math.sin(particle.position.x));\n    }\n\n    const initialPosition = particle.initialPosition;\n    const initialDistance = Utils_1.NumberUtils.getDistance(initialPosition, particle.position);\n\n    if (particle.maxDistance) {\n      if (initialDistance >= particle.maxDistance && !particle.misplaced) {\n        particle.misplaced = initialDistance > particle.maxDistance;\n        particle.velocity.horizontal = particle.velocity.vertical / 2 - particle.velocity.horizontal;\n        particle.velocity.vertical = particle.velocity.horizontal / 2 - particle.velocity.vertical;\n      } else if (initialDistance < particle.maxDistance && particle.misplaced) {\n        particle.misplaced = false;\n      } else if (particle.misplaced) {\n        if (particle.position.x < initialPosition.x && particle.velocity.horizontal < 0 || particle.position.x > initialPosition.x && particle.velocity.horizontal > 0) {\n          particle.velocity.horizontal *= -Math.random();\n        }\n\n        if (particle.position.y < initialPosition.y && particle.velocity.vertical < 0 || particle.position.y > initialPosition.y && particle.velocity.vertical > 0) {\n          particle.velocity.vertical *= -Math.random();\n        }\n      }\n    }\n  }\n\n  applyNoise(delta) {\n    const particle = this.particle;\n    const particlesOptions = particle.particlesOptions;\n    const noiseOptions = particlesOptions.move.noise;\n    const noiseEnabled = noiseOptions.enable;\n\n    if (!noiseEnabled) {\n      return;\n    }\n\n    const container = this.container;\n\n    if (particle.lastNoiseTime <= particle.noiseDelay) {\n      particle.lastNoiseTime += delta.value;\n      return;\n    }\n\n    const noise = container.noise.generate(particle);\n    particle.velocity.horizontal += Math.cos(noise.angle) * noise.length;\n    particle.velocity.horizontal = Utils_1.NumberUtils.clamp(particle.velocity.horizontal, -1, 1);\n    particle.velocity.vertical += Math.sin(noise.angle) * noise.length;\n    particle.velocity.vertical = Utils_1.NumberUtils.clamp(particle.velocity.vertical, -1, 1);\n    particle.lastNoiseTime -= particle.noiseDelay;\n  }\n\n  moveParallax() {\n    const container = this.container;\n    const options = container.options;\n\n    if (Utils_1.Utils.isSsr() || !options.interactivity.events.onHover.parallax.enable) {\n      return;\n    }\n\n    const particle = this.particle;\n    const parallaxForce = options.interactivity.events.onHover.parallax.force;\n    const mousePos = container.interactivity.mouse.position;\n\n    if (!mousePos) {\n      return;\n    }\n\n    const canvasCenter = {\n      x: container.canvas.size.width / 2,\n      y: container.canvas.size.height / 2\n    };\n    const parallaxSmooth = options.interactivity.events.onHover.parallax.smooth;\n    const factor = particle.getRadius() / parallaxForce;\n    const tmp = {\n      x: (mousePos.x - canvasCenter.x) * factor,\n      y: (mousePos.y - canvasCenter.y) * factor\n    };\n    particle.offset.x += (tmp.x - particle.offset.x) / parallaxSmooth;\n    particle.offset.y += (tmp.y - particle.offset.y) / parallaxSmooth;\n  }\n\n  getProximitySpeedFactor() {\n    const container = this.container;\n    const options = container.options;\n    const active = Utils_1.Utils.isInArray(Enums_1.HoverMode.slow, options.interactivity.events.onHover.mode);\n\n    if (!active) {\n      return 1;\n    }\n\n    const mousePos = this.container.interactivity.mouse.position;\n\n    if (!mousePos) {\n      return 1;\n    }\n\n    const particlePos = this.particle.getPosition();\n    const dist = Utils_1.NumberUtils.getDistance(mousePos, particlePos);\n    const radius = container.retina.slowModeRadius;\n\n    if (dist > radius) {\n      return 1;\n    }\n\n    const proximityFactor = dist / radius || 0;\n    const slowFactor = options.interactivity.modes.slow.factor;\n    return proximityFactor / slowFactor;\n  }\n\n}\n\nexports.Mover = Mover;","map":null,"metadata":{},"sourceType":"script"}