{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport * as THREE from 'three';\nimport { Layers, Vector2, Raycaster, Scene, OrthographicCamera, PerspectiveCamera, Clock, Vector3, Math as Math$1, PCFSoftShadowMap, WebGLRenderer } from 'three';\nimport Reconciler from 'react-reconciler';\nimport { unstable_now, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';\nimport React__default, { createContext, useState, useRef, useMemo, useCallback, useLayoutEffect, useEffect, createElement, useContext as useContext$1 } from 'react';\nimport { TinyEmitter } from 'tiny-emitter';\nimport usePromise from 'react-promise-suspense';\nimport ReactDOM from 'react-dom';\nimport useMeasure from 'react-use-measure';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport mergeRefs from 'react-merge-refs';\nvar version = \"4.0.0-beta.12\";\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nconst roots = new Map();\nconst emptyObject = {};\nconst is = {\n  obj: a => a === Object(a),\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n\n  equ(a, b) {\n    // Wrong type, doesn't match\n    if (typeof a !== typeof b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    let i;\n\n    for (i in a) if (!(i in b)) return false;\n\n    for (i in b) if (a[i] !== b[i]) return false;\n\n    return is.und(i) ? a === b : true;\n  }\n\n};\nlet globalEffects = [];\n\nfunction addEffect(callback) {\n  globalEffects.push(callback);\n}\n\nfunction renderGl(state, timestamp, repeat = 0, runGlobalEffects = false) {\n  // Run global effects\n  if (runGlobalEffects) globalEffects.forEach(effect => effect(timestamp) && repeat++); // Run local effects\n\n  const delta = state.current.clock.getDelta();\n  state.current.subscribers.forEach(sub => sub.ref.current(state.current, delta)); // Decrease frame count\n\n  state.current.frames = Math.max(0, state.current.frames - 1);\n  repeat += !state.current.invalidateFrameloop ? 1 : state.current.frames; // Render content\n\n  if (!state.current.manual) state.current.gl.render(state.current.scene, state.current.camera);\n  return repeat;\n}\n\nlet running = false;\n\nfunction renderLoop(timestamp) {\n  running = true;\n  let repeat = 0; // Run global effects\n\n  globalEffects.forEach(effect => effect(timestamp) && repeat++);\n  roots.forEach(root => {\n    const state = root.containerInfo.__state; // If the frameloop is invalidated, do not run another frame\n\n    if (state.current.active && state.current.ready && (!state.current.invalidateFrameloop || state.current.frames > 0)) repeat = renderGl(state, timestamp, repeat);\n  });\n  if (repeat !== 0) return requestAnimationFrame(renderLoop); // Flag end of operation\n\n  running = false;\n}\n\nfunction invalidate(state = true, frames = 2) {\n  if (state === true) roots.forEach(root => root.containerInfo.__state.current.frames = frames);else if (state && state.current) {\n    if (state.current.vr) return;\n    state.current.frames = frames;\n  }\n\n  if (!running) {\n    running = true;\n    requestAnimationFrame(renderLoop);\n  }\n}\n\nlet catalogue = {};\n\nconst extend = objects => void (catalogue = _extends({}, catalogue, {}, objects));\n\nfunction applyProps(instance, newProps, oldProps = {}, accumulative = false) {\n  // Filter equals, events and reserved props\n  const container = instance.__container;\n  const sameProps = Object.keys(newProps).filter(key => is.equ(newProps[key], oldProps[key]));\n  const handlers = Object.keys(newProps).filter(key => typeof newProps[key] === 'function' && key.startsWith('on'));\n  const leftOvers = accumulative ? Object.keys(oldProps).filter(key => newProps[key] === void 0) : [];\n  const filteredProps = [...sameProps, 'children', 'key', 'ref'].reduce((acc, prop) => {\n    let rest = _objectWithoutPropertiesLoose(acc, [prop].map(_toPropertyKey));\n\n    return rest;\n  }, newProps); // Add left-overs as undefined props so they can be removed\n\n  leftOvers.forEach(key => filteredProps[key] = undefined);\n\n  if (Object.keys(filteredProps).length > 0) {\n    Object.entries(filteredProps).forEach(([key, value]) => {\n      if (!handlers.includes(key)) {\n        let root = instance;\n        let target = root[key];\n\n        if (key.includes('-')) {\n          const entries = key.split('-');\n          target = entries.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\n\n          if (!(target && target.set)) {\n            const [name, ...reverseEntries] = entries.reverse();\n            root = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n            key = name;\n          }\n        } // Special treatment for objects with support for set/copy\n\n\n        if (target && target.set && (target.copy || target instanceof Layers)) {\n          if (target.copy && target.constructor.name === value.constructor.name) target.copy(value);else if (Array.isArray(value)) target.set(...value);else target.set(value); // Else, just overwrite the value\n        } else root[key] = value;\n\n        invalidateInstance(instance);\n      }\n    }); // Preemptively delete the instance from the containers interaction\n\n    if (accumulative && container && instance.raycast && instance.__handlers) {\n      instance.__handlers = undefined;\n\n      const index = container.__interaction.indexOf(instance);\n\n      if (index > -1) container.__interaction.splice(index, 1);\n    } // Prep interaction handlers\n\n\n    if (handlers.length) {\n      // Add interactive object to central container\n      if (container && instance.raycast) {\n        // Unless the only onUpdate is the only event present we flag the instance as interactive\n        if (!(handlers.length === 1 && handlers[0] === 'onUpdate')) container.__interaction.push(instance);\n      } // Add handlers to the instances handler-map\n\n\n      instance.__handlers = handlers.reduce((acc, key) => _extends({}, acc, {\n        [key.charAt(2).toLowerCase() + key.substr(3)]: newProps[key]\n      }), {});\n    } // Call the update lifecycle when it is being updated, but only when it is part of the scene\n\n\n    if (instance.parent) updateInstance(instance);\n  }\n}\n\nfunction invalidateInstance(instance) {\n  if (instance.__container && instance.__container.__state) invalidate(instance.__container.__state);\n}\n\nfunction updateInstance(instance) {\n  if (instance.__handlers && instance.__handlers.update) instance.__handlers.update(instance);\n}\n\nfunction createInstance(type, _ref, container, hostContext, internalInstanceHandle) {\n  let {\n    args = []\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"args\"]);\n\n  let name = \"\" + type[0].toUpperCase() + type.slice(1);\n  let instance;\n\n  if (type === 'primitive') {\n    instance = props.object;\n    instance.__instance = true;\n  } else if (type === 'new') {\n    instance = new props.object(args);\n  } else {\n    const target = catalogue[name] || THREE[name];\n    instance = is.arr(args) ? new target(...args) : new target(args);\n  } // Bind to the root container in case portals are being used\n  // This is perhaps better for event management as we can keep them on a single instance\n\n\n  while (container.__container) {\n    container = container.__container;\n  } // TODO: https://github.com/facebook/react/issues/17147\n  // If it's still not there it means the portal was created on a virtual node outside of react\n\n\n  if (!roots.has(container)) {\n    const fn = node => {\n      if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);\n    };\n\n    container = fn(internalInstanceHandle);\n  } // Apply initial props\n\n\n  instance.__objects = [];\n  instance.__container = container; // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n  // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n  // why it passes \"false\" here\n\n  applyProps(instance, props, {});\n  return instance;\n}\n\nfunction appendChild(parentInstance, child) {\n  if (child) {\n    if (child.isObject3D) parentInstance.add(child);else {\n      parentInstance.__objects.push(child);\n\n      child.parent = parentInstance; // The attach attribute implies that the object attaches itself on the parent\n\n      if (child.attach) parentInstance[child.attach] = child;else if (child.attachArray) {\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n        parentInstance[child.attachArray].push(child);\n      } else if (child.attachObject) {\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n      }\n    }\n    updateInstance(child);\n    invalidateInstance(child);\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  if (child) {\n    if (child.isObject3D) {\n      child.parent = parentInstance;\n      child.dispatchEvent({\n        type: 'added'\n      }); // TODO: the order is out of whack if data objects are present, has to be recalculated\n\n      const index = parentInstance.children.indexOf(beforeChild);\n      parentInstance.children = [...parentInstance.children.slice(0, index), child, ...parentInstance.children.slice(index)];\n      updateInstance(child);\n    } else appendChild(parentInstance, child); // TODO: order!!!\n\n\n    invalidateInstance(child);\n  }\n}\n\nfunction removeRecursive(array, parent, clone = false) {\n  if (array) {\n    // Three uses splice op's internally we may have to shallow-clone the array in order to safely remove items\n    const target = clone ? [...array] : array;\n    target.forEach(child => removeChild(parent, child));\n  }\n}\n\nfunction removeChild(parentInstance, child) {\n  if (child) {\n    if (child.isObject3D) {\n      parentInstance.remove(child);\n    } else {\n      child.parent = null;\n      parentInstance.__objects = parentInstance.__objects.filter(x => x !== child); // Remove attachment\n\n      if (child.attach) parentInstance[child.attach] = null;else if (child.attachArray) parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);else if (child.attachObject) {\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n      }\n    }\n\n    invalidateInstance(child); // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\n\n    if (child.dispose !== null) {\n      unstable_runWithPriority(unstable_IdlePriority, () => {\n        // Remove interactivity\n        if (child.__container) child.__container.__interaction = child.__container.__interaction.filter(x => x !== child); // Remove nested child objects\n\n        removeRecursive(child.__objects, child);\n        removeRecursive(child.children, child, true); // Dispose item\n\n        if (child.dispose) child.dispose(); // Remove references\n\n        delete child.__container;\n        delete child.__objects;\n      });\n    }\n  }\n}\n\nfunction switchInstance(instance, type, newProps, fiber) {\n  const parent = instance.parent;\n  const newInstance = createInstance(type, newProps, instance.__container, null, fiber);\n  removeChild(parent, instance);\n  appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n  // https://github.com/facebook/react/issues/14983\n  // https://github.com/facebook/react/pull/15021\n  ;\n  [fiber, fiber.alternate].forEach(fiber => {\n    if (fiber !== null) {\n      fiber.stateNode = newInstance;\n\n      if (fiber.ref) {\n        if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n      }\n    }\n  });\n}\n\nconst Renderer = Reconciler({\n  now: unstable_now,\n  createInstance,\n  removeChild,\n  appendChild,\n  insertBefore,\n  supportsMutation: true,\n  isPrimaryRenderer: false,\n  // @ts-ignore\n  scheduleTimeout: typeof setTimeout === 'function' ? setTimeout : undefined,\n  cancelTimeout: typeof clearTimeout === 'function' ? clearTimeout : undefined,\n  noTimeout: -1,\n  appendInitialChild: appendChild,\n  appendChildToContainer: appendChild,\n  removeChildFromContainer: removeChild,\n  insertInContainerBefore: insertBefore,\n\n  commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\n    if (instance.__instance && newProps.object && newProps.object !== instance) {\n      // <instance object={...} /> where the object reference has changed\n      switchInstance(instance, type, newProps, fiber);\n    } else {\n      // This is a data object, let's extract critical information about it\n      const {\n        args: argsNew = []\n      } = newProps,\n            restNew = _objectWithoutPropertiesLoose(newProps, [\"args\"]);\n\n      const {\n        args: argsOld = []\n      } = oldProps,\n            restOld = _objectWithoutPropertiesLoose(oldProps, [\"args\"]); // If it has new props or arguments, then it needs to be re-instanciated\n\n\n      const hasNewArgs = argsNew.some((value, index) => is.obj(value) ? Object.entries(value).some(([key, val]) => val !== argsOld[index][key]) : value !== argsOld[index]);\n\n      if (hasNewArgs) {\n        // Next we create a new instance and append it again\n        switchInstance(instance, type, newProps, fiber);\n      } else {\n        // Otherwise just overwrite props\n        applyProps(instance, restNew, restOld, true);\n      }\n    }\n  },\n\n  hideInstance(instance) {\n    if (instance.isObject3D) {\n      instance.visible = false;\n      invalidateInstance(instance);\n    }\n  },\n\n  unhideInstance(instance, props) {\n    if (instance.isObject3D && props.visible == null || props.visible) {\n      instance.visible = true;\n      invalidateInstance(instance);\n    }\n  },\n\n  getPublicInstance(instance) {\n    return instance;\n  },\n\n  getRootHostContext() {\n    return emptyObject;\n  },\n\n  getChildHostContext() {\n    return emptyObject;\n  },\n\n  createTextInstance() {},\n\n  finalizeInitialChildren() {\n    return false;\n  },\n\n  prepareUpdate() {\n    return emptyObject;\n  },\n\n  shouldDeprioritizeSubtree() {\n    return false;\n  },\n\n  prepareForCommit() {},\n\n  resetAfterCommit() {},\n\n  shouldSetTextContent() {\n    return false;\n  }\n\n});\nconst LegacyRoot = 0;\nconst ConcurrentRoot = 2;\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\nconst REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n\nfunction render(element, container, state) {\n  let root = roots.get(container);\n\n  if (!root) {\n    container.__state = state;\n    let newRoot = root = Renderer.createContainer(container, state !== undefined && state.current.concurrent ? ConcurrentRoot : LegacyRoot, false);\n    roots.set(container, newRoot);\n  }\n\n  Renderer.updateContainer(element, root, null, () => undefined);\n  return Renderer.getPublicRootInstance(root);\n}\n\nfunction unmountComponentAtNode(container) {\n  const root = roots.get(container);\n  if (root) Renderer.updateContainer(null, root, null, () => void roots.delete(container));\n}\n\nfunction createPortal(children, containerInfo, implementation, key = null) {\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children,\n    containerInfo,\n    implementation\n  };\n}\n\nRenderer.injectIntoDevTools({\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\n  version: version,\n  rendererPackageName: 'react-three-fiber',\n  findHostInstanceByFiber: Renderer.findHostInstance\n});\n\nfunction isOrthographicCamera(def) {\n  return def.isOrthographicCamera;\n}\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index;\n}\n\nconst stateContext = createContext({});\n\nconst useCanvas = props => {\n  const {\n    children,\n    gl,\n    camera,\n    orthographic,\n    raycaster,\n    size,\n    pixelRatio,\n    vr = false,\n    concurrent = false,\n    shadowMap = false,\n    invalidateFrameloop = false,\n    updateDefaultCamera = true,\n    noEvents = false,\n    onCreated,\n    onPointerMissed\n  } = props; // Local, reactive state\n\n  const [ready, setReady] = useState(false);\n  const [mouse] = useState(() => new Vector2());\n  const [defaultRaycaster] = useState(() => {\n    const ray = new Raycaster();\n\n    if (raycaster) {\n      const raycasterProps = _objectWithoutPropertiesLoose(raycaster, [\"filter\"]);\n\n      applyProps(ray, raycasterProps, {});\n    }\n\n    return ray;\n  });\n  const [defaultScene] = useState(() => {\n    const scene = new Scene();\n    scene.__interaction = [];\n    scene.__objects = [];\n    return scene;\n  });\n  const [defaultCam, _setDefaultCamera] = useState(() => {\n    const cam = orthographic ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new PerspectiveCamera(75, 0, 0.1, 1000);\n    cam.position.z = 5;\n    if (camera) applyProps(cam, camera, {});\n    return cam;\n  });\n  const [clock] = useState(() => new Clock()); // Public state\n\n  const state = useRef({\n    ready: false,\n    active: true,\n    manual: 0,\n    vr,\n    concurrent,\n    noEvents,\n    invalidateFrameloop: false,\n    frames: 0,\n    aspect: 0,\n    subscribers: [],\n    camera: defaultCam,\n    scene: defaultScene,\n    raycaster: defaultRaycaster,\n    mouse,\n    clock,\n    gl,\n    size,\n    viewport: {\n      width: 0,\n      height: 0,\n      factor: 0\n    },\n    initialClick: [0, 0],\n    initialHits: [],\n    pointer: new TinyEmitter(),\n    captured: undefined,\n    events: undefined,\n    subscribe: (ref, priority = 0) => {\n      // If this subscription was given a priority, it takes rendering into its own hands\n      // For that reason we switch off automatic rendering and increase the manual flag\n      // As long as this flag is positive (there could be multiple render subscription)\n      // ..there can be no internal rendering at all\n      if (priority) state.current.manual++;\n      state.current.subscribers.push({\n        ref,\n        priority: priority\n      }); // Sort layers from lowest to highest, meaning, highest priority renders last (on top of the other frames)\n\n      state.current.subscribers = state.current.subscribers.sort((a, b) => a.priority - b.priority);\n      return () => {\n        // Decrease manual flag if this subscription had a priority\n        if (priority) state.current.manual--;\n        state.current.subscribers = state.current.subscribers.filter(s => s.ref !== ref);\n      };\n    },\n    setDefaultCamera: camera => _setDefaultCamera(camera),\n    invalidate: () => invalidate(state),\n    intersect: event => handlePointerMove(event || {})\n  }); // Writes locals into public state for distribution among subscribers, context, etc\n\n  useMemo(() => {\n    state.current.ready = ready;\n    state.current.size = size;\n    state.current.camera = defaultCam;\n    state.current.invalidateFrameloop = invalidateFrameloop;\n    state.current.vr = vr;\n    state.current.gl = gl;\n    state.current.concurrent = concurrent;\n    state.current.noEvents = noEvents;\n  }, [invalidateFrameloop, vr, concurrent, noEvents, ready, size, defaultCam, gl]); // Adjusts default camera\n\n  useMemo(() => {\n    state.current.aspect = size.width / size.height;\n\n    if (isOrthographicCamera(defaultCam)) {\n      state.current.viewport = {\n        width: size.width,\n        height: size.height,\n        factor: 1\n      };\n    } else {\n      const target = new Vector3(0, 0, 0);\n      const distance = defaultCam.position.distanceTo(target);\n      const fov = Math$1.degToRad(defaultCam.fov); // convert vertical fov to radians\n\n      const height = 2 * Math.tan(fov / 2) * distance; // visible height\n\n      const width = height * state.current.aspect;\n      state.current.viewport = {\n        width,\n        height,\n        factor: size.width / width\n      };\n    } // #92 (https://github.com/drcmda/react-three-fiber/issues/92)\n    // Sometimes automatic default camera adjustment isn't wanted behaviour\n\n\n    if (updateDefaultCamera) {\n      if (isOrthographicCamera(defaultCam)) {\n        defaultCam.left = size.width / -2;\n        defaultCam.right = size.width / 2;\n        defaultCam.top = size.height / 2;\n        defaultCam.bottom = size.height / -2;\n      } else {\n        defaultCam.aspect = state.current.aspect;\n      }\n\n      defaultCam.updateProjectionMatrix(); // #178: https://github.com/react-spring/react-three-fiber/issues/178\n      // Update matrix world since the renderer is a frame late\n\n      defaultCam.updateMatrixWorld();\n    }\n\n    gl.setSize(size.width, size.height);\n    if (ready) invalidate(state);\n  }, [defaultCam, size, updateDefaultCamera]);\n  /** Events ------------------------------------------------------------------------------------------------ */\n\n  /** Sets up defaultRaycaster */\n\n  const prepareRay = useCallback(({\n    clientX,\n    clientY\n  }) => {\n    if (clientX !== void 0) {\n      const {\n        left,\n        right,\n        top,\n        bottom\n      } = state.current.size;\n      mouse.set((clientX - left) / (right - left) * 2 - 1, -((clientY - top) / (bottom - top)) * 2 + 1);\n      defaultRaycaster.setFromCamera(mouse, state.current.camera);\n    }\n  }, []);\n  /** Intersects interaction objects using the event input */\n\n  const intersect = useCallback((event, prepare = true) => {\n    // Skip event handling when noEvents is set\n    if (state.current.noEvents) return [];\n    if (prepare) prepareRay(event);\n    const seen = new Set();\n    const hits = []; // Intersect known handler objects and filter against duplicates\n\n    let intersects = defaultRaycaster.intersectObjects(state.current.scene.__interaction, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    }); // #16031: (https://github.com/mrdoob/three.js/issues/16031)\n    // Allow custom userland intersect sort order\n\n    if (raycaster && raycaster.filter && sharedState.current) intersects = raycaster.filter(intersects, sharedState.current);\n\n    for (let intersect of intersects) {\n      let eventObject = intersect.object; // Bubble event up\n\n      while (eventObject) {\n        const handlers = eventObject.__handlers;\n        if (handlers) hits.push(_extends({}, intersect, {\n          eventObject\n        }));\n        eventObject = eventObject.parent;\n      }\n    }\n\n    return hits;\n  }, []);\n  /**  Calculates click deltas */\n\n  const calculateDistance = useCallback(event => {\n    let dx = event.clientX - state.current.initialClick[0];\n    let dy = event.clientY - state.current.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }, []);\n  const hovered = useMemo(() => new Map(), []);\n  /**  Handles intersections by forwarding them to handlers */\n\n  const handleIntersects = useCallback((event, fn) => {\n    prepareRay(event); // Get fresh intersects\n\n    const hits = intersect(event, false); // If the interaction is captured take that into account, the captured event has to be part of the intersects\n\n    if (state.current.captured && event.type !== 'click' && event.type !== 'wheel') {\n      state.current.captured.forEach(captured => {\n        if (!hits.find(hit => hit.eventObject === captured.eventObject)) hits.push(captured);\n      });\n    } // If anything has been found, forward it to the event listeners\n\n\n    if (hits.length) {\n      const unprojectedPoint = new Vector3(mouse.x, mouse.y, 0).unproject(state.current.camera);\n      const delta = event.type === 'click' ? calculateDistance(event) : 0;\n\n      for (let hit of hits) {\n        let stopped = {\n          current: false\n        };\n\n        let raycastEvent = _extends({}, event, {}, hit, {\n          stopped,\n          delta,\n          unprojectedPoint,\n          ray: defaultRaycaster.ray,\n          camera: state.current.camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => stopped.current = true,\n          sourceEvent: event\n        });\n\n        fn(raycastEvent);\n\n        if (stopped.current === true) {\n          // Propagation is stopped, remove all other hover records\n          // An event handler is only allowed to flush other handlers if it is hovered itself\n          if (hovered.size && Array.from(hovered.values()).find(i => i.object === hit.object)) {\n            handlePointerCancel(raycastEvent, [hit]);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return hits;\n  }, []);\n  const handlePointerMove = useCallback(event => {\n    state.current.pointer.emit('pointerMove', event);\n    const hits = handleIntersects(event, data => {\n      const eventObject = data.eventObject;\n      const handlers = eventObject.__handlers; // Check presence of handlers\n\n      if (!handlers) return; // Call mouse move\n\n      if (handlers.pointerMove) handlers.pointerMove(data); // Check if mouse enter or out is present\n\n      if (handlers.pointerOver || handlers.pointerEnter || handlers.pointerOut || handlers.pointerLeave) {\n        const id = makeId(data);\n        const hoveredItem = hovered.get(id);\n\n        if (!hoveredItem) {\n          // If the object wasn't previously hovered, book it and call its handler\n          hovered.set(id, data);\n          if (handlers.pointerOver) handlers.pointerOver(_extends({}, data, {\n            type: 'pointerover'\n          }));\n          if (handlers.pointerEnter) handlers.pointerEnter(_extends({}, data, {\n            type: 'pointerEnter'\n          }));\n        } else if (hoveredItem.stopped.current) {\n          // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n          data.stopPropagation();\n        }\n      }\n    }); // Take care of unhover\n\n    handlePointerCancel(event, hits);\n    return hits;\n  }, []);\n  const handlePointerCancel = useCallback((event, hits) => {\n    state.current.pointer.emit('pointerCancel', event);\n    if (!hits) hits = handleIntersects(event, () => null);\n    Array.from(hovered.values()).forEach(data => {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (hits && (!hits.length || !hits.find(i => i.eventObject === data.eventObject))) {\n        const eventObject = data.eventObject;\n        const handlers = eventObject.__handlers;\n\n        if (handlers) {\n          if (handlers.pointerOut) handlers.pointerOut(_extends({}, data, {\n            type: 'pointerout'\n          }));\n          if (handlers.pointerLeave) handlers.pointerLeave(_extends({}, data, {\n            type: 'pointerleave'\n          }));\n        }\n\n        hovered.delete(makeId(data));\n      }\n    });\n  }, []);\n  const handlePointer = useCallback(name => event => {\n    state.current.pointer.emit(name, event); // Collect hits\n\n    const hits = handleIntersects(event, data => {\n      const eventObject = data.eventObject;\n      const handlers = eventObject.__handlers;\n\n      if (handlers && handlers[name]) {\n        // Forward all events back to their respective handlers with the exception of click,\n        // which must must the initial target\n        if (name !== 'click' || state.current.initialHits.includes(eventObject)) handlers[name](data);\n      }\n    }); // If a click yields no results, pass it back to the user as a miss\n\n    if (name === 'pointerDown') {\n      state.current.initialClick = [event.clientX, event.clientY];\n      state.current.initialHits = hits.map(hit => hit.eventObject);\n    }\n\n    if (name === 'click' && !hits.length && onPointerMissed) {\n      if (calculateDistance(event) <= 2) onPointerMissed();\n    }\n  }, [onPointerMissed]);\n  useMemo(() => {\n    state.current.events = {\n      onClick: handlePointer('click'),\n      onWheel: handlePointer('wheel'),\n      onPointerDown: handlePointer('pointerDown'),\n      onPointerUp: handlePointer('pointerUp'),\n      onPointerLeave: e => handlePointerCancel(e, []),\n      onPointerMove: handlePointerMove,\n      onGotPointerCapture: e => state.current.captured = intersect(e, false),\n      onLostPointerCapture: e => (state.current.captured = undefined, handlePointerCancel(e))\n    };\n  }, [onPointerMissed]);\n  /** Events ------------------------------------------------------------------------------------------------- */\n  // Only trigger the context provider when necessary\n\n  const sharedState = useRef();\n  useMemo(() => {\n    const _state$current = state.current,\n          props = _objectWithoutPropertiesLoose(_state$current, [\"ready\", \"manual\", \"vr\", \"noEvents\", \"invalidateFrameloop\", \"frames\", \"subscribers\", \"captured\", \"initialClick\", \"initialHits\"]);\n\n    sharedState.current = props;\n  }, [size, defaultCam]); // Update pixel ratio\n\n  useLayoutEffect(() => void (pixelRatio && gl.setPixelRatio(pixelRatio)), [pixelRatio]); // Update shadowmap\n\n  useLayoutEffect(() => {\n    if (shadowMap) {\n      gl.shadowMap.enabled = true;\n      if (typeof shadowMap === 'object') Object.assign(gl, shadowMap);else gl.shadowMap.type = PCFSoftShadowMap;\n    }\n  }, [shadowMap]); // This component is a bridge into the three render context, when it gets rendererd\n  // we know we are ready to compile shaders, call subscribers, etc\n\n  const IsReady = useCallback(() => {\n    const activate = () => setReady(true);\n\n    useEffect(() => {\n      const result = onCreated && onCreated(state.current);\n      return void (result && result.then ? result.then(activate) : activate());\n    }, []);\n    return null;\n  }, []); // Render v-dom into scene\n\n  useLayoutEffect(() => {\n    render(createElement(stateContext.Provider, {\n      value: sharedState.current\n    }, typeof children === 'function' ? children(state.current) : children, createElement(IsReady, null)), defaultScene, state);\n  }, [ready, children, sharedState.current]);\n  useLayoutEffect(() => {\n    if (ready) {\n      // Start render-loop, either via RAF or setAnimationLoop for VR\n      if (!state.current.vr) {\n        invalidate(state);\n      } else if (gl.vr && gl.setAnimationLoop) {\n        gl.vr.enabled = true;\n        gl.setAnimationLoop(t => renderGl(state, t, 0, true));\n      } else console.warn('the gl instance does not support VR!');\n    }\n  }, [ready]); // Dispose renderer on unmount\n\n  useEffect(() => () => {\n    if (state.current.gl) {\n      if (state.current.gl.forceContextLoss) state.current.gl.forceContextLoss();\n      if (state.current.gl.dispose) state.current.gl.dispose();\n      state.current.gl = undefined;\n      unmountComponentAtNode(state.current.scene);\n      state.current.active = false;\n    }\n  }, []);\n  return state.current.events;\n};\n\nfunction useContext(context) {\n  let result = useContext$1(context);\n\n  if (!result) {\n    console.warn('hooks can only be used within the canvas! https://github.com/react-spring/react-three-fiber#hooks');\n  }\n\n  return result;\n}\n\nfunction useFrame(callback, renderPriority = 0) {\n  const {\n    subscribe\n  } = useContext(stateContext); // Update ref\n\n  const ref = useRef(callback);\n  useLayoutEffect(() => void (ref.current = callback), [callback]); // Subscribe/unsub\n\n  useEffect(() => {\n    const unsubscribe = subscribe(ref, renderPriority);\n    return () => unsubscribe();\n  }, [renderPriority]);\n}\n\nfunction useThree() {\n  return useContext(stateContext);\n}\n\nfunction useUpdate(callback, dependents, optionalRef) {\n  const {\n    invalidate\n  } = useContext(stateContext);\n  const localRef = useRef();\n  const ref = optionalRef ? optionalRef : localRef;\n  useEffect(() => {\n    if (ref.current) {\n      callback(ref.current);\n      invalidate();\n    }\n  }, dependents);\n  return ref;\n}\n\nfunction useResource(optionalRef) {\n  const [_, forceUpdate] = useState(false);\n  const localRef = useRef(undefined);\n  const ref = optionalRef ? optionalRef : localRef;\n  useEffect(() => void forceUpdate(i => !i), [ref.current]);\n  return [ref, ref.current];\n}\n\nconst blackList = ['id', 'uuid', 'type', 'children', 'parent', 'matrix', 'matrixWorld', 'matrixWorldNeedsUpdate', 'modelViewMatrix', 'normalMatrix'];\n\nfunction prune(props) {\n  const reducedProps = _extends({}, props); // Remove black listed props\n\n\n  blackList.forEach(name => delete reducedProps[name]); // Remove functions\n\n  Object.keys(reducedProps).forEach(name => typeof reducedProps[name] === 'function' && delete reducedProps[name]); // Prune materials and geometries\n\n  if (reducedProps.material) reducedProps.material = prune(reducedProps.material);\n  if (reducedProps.geometry) reducedProps.geometry = prune(reducedProps.geometry); // Return cleansed object\n\n  return reducedProps;\n}\n\nfunction useLoader(Proto, url, extensions) {\n  const loader = useMemo(() => {\n    // Construct new loader\n    const temp = new Proto(); // Run loader extensions\n\n    if (extensions) extensions(temp);\n    return temp;\n  }, [Proto]); // Use suspense to load async assets\n\n  const results = usePromise((Proto, url) => {\n    const urlArray = Array.isArray(url) ? url : [url];\n    return Promise.all(urlArray.map(url => new Promise(res => loader.load(url, data => {\n      const objects = [];\n      if (data.scene) data.scene.traverse(props => objects.push(prune(props)));\n      data.__$ = objects;\n      res(data);\n    }))));\n  }, [Proto, url]); // Dispose objects on unmount\n\n  useEffect(() => () => results.forEach(data => {\n    if (data.dispose) data.dispose();\n    if (data.scene && data.scene.dispose) data.scene.dispose();\n  }), []); // Temporary hack to make the new api backwards compatible for a while ...\n\n  const isArray = Array.isArray(url);\n\n  if (!isArray) {\n    Object.assign(results[0], {\n      [Symbol.iterator]() {\n        console.warn('[value]=useLoader(...) is deprecated, please use value=useLoader(...) instead!');\n        return [results[0]][Symbol.iterator]();\n      }\n\n    });\n  } // Return the object itself and a list of pruned props\n\n\n  return isArray ? results : results[0];\n}\n\nfunction useCamera(camera, props) {\n  const {\n    mouse\n  } = useThree();\n  const [raycast] = useState(() => {\n    let raycaster = new Raycaster();\n    if (props) applyProps(raycaster, props, {});\n    let originalRaycast = undefined;\n    return function (_, intersects) {\n      raycaster.setFromCamera(mouse, camera);\n      if (!originalRaycast) originalRaycast = this.constructor.prototype.raycast.bind(this);\n      if (originalRaycast) originalRaycast(raycaster, intersects);\n    };\n  });\n  return raycast;\n}\n\nconst vector = new Vector3();\n\nfunction calculatePosition(el, camera, viewport) {\n  vector.setFromMatrixPosition(el.matrixWorld);\n  vector.project(camera);\n  return [(vector.x + 1) * viewport.width / 2, (-vector.y + 1) * viewport.height / 2];\n}\n\nconst Dom = React__default.forwardRef((_ref, ref) => {\n  let {\n    children,\n    eps = 0.001,\n    style,\n    className,\n    prepend,\n    center\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\", \"eps\", \"style\", \"className\", \"prepend\", \"center\"]);\n\n  const {\n    gl,\n    scene,\n    camera,\n    viewport\n  } = useThree();\n  const [el] = useState(() => document.createElement('div'));\n  const group = useRef(null);\n  const old = useRef([0, 0]);\n  useEffect(() => {\n    if (group.current) {\n      scene.updateMatrixWorld();\n      const vec = calculatePosition(group.current, camera, viewport);\n      el.style.cssText = \"position:absolute;top:0;left:0;transform:translate3d(\" + vec[0] + \"px,\" + vec[1] + \"px,0);\";\n\n      if (gl.domElement.parentNode) {\n        if (prepend) gl.domElement.parentNode.prepend(el);else gl.domElement.parentNode.appendChild(el);\n      }\n\n      return () => {\n        if (gl.domElement.parentNode) gl.domElement.parentNode.removeChild(el);\n        ReactDOM.unmountComponentAtNode(el);\n      };\n    }\n  }, []);\n  useEffect(() => void ReactDOM.render(React__default.createElement(\"div\", {\n    style: _extends({\n      transform: center ? 'translate3d(-50%,-50%,0)' : 'none'\n    }, style),\n    className: className,\n    ref: ref\n  }, children), el));\n  useFrame(() => {\n    if (group.current) {\n      const vec = calculatePosition(group.current, camera, viewport);\n\n      if (Math.abs(old.current[0] - vec[0]) > eps || Math.abs(old.current[1] - vec[1]) > eps) {\n        el.style.transform = \"translate3d(\" + vec[0] + \"px,\" + vec[1] + \"px,0)\";\n      }\n\n      old.current = vec;\n    }\n  });\n  return React__default.createElement(\"group\", _extends({}, props, {\n    ref: group\n  }));\n});\nconst defaultStyles = {\n  position: 'relative',\n  width: '100%',\n  height: '100%',\n  overflow: 'hidden'\n};\n\nfunction Content(_ref) {\n  let {\n    children,\n    setEvents,\n    container,\n    renderer,\n    effects\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\", \"setEvents\", \"container\", \"renderer\", \"effects\"]); // Create renderer\n\n\n  const [gl] = useState(renderer);\n  if (!gl) console.warn('No renderer created!'); // Mount and unmount managemenbt\n\n  useEffect(() => effects && effects(gl, container), []); // Init canvas, fetch events, hand them back to the wrapping div\n\n  const events = useCanvas(_extends({}, props, {\n    children,\n    gl: gl\n  }));\n  useEffect(() => void setEvents(events), [events]);\n  return null;\n}\n\nconst ResizeContainer = React__default.memo(props => {\n  const {\n    preRender,\n    resize,\n    style\n  } = props,\n        restSpread = _objectWithoutPropertiesLoose(props, [\"renderer\", \"effects\", \"preRender\", \"children\", \"vr\", \"gl2\", \"concurrent\", \"shadowMap\", \"orthographic\", \"resize\", \"invalidateFrameloop\", \"updateDefaultCamera\", \"noEvents\", \"gl\", \"camera\", \"raycaster\", \"pixelRatio\", \"style\", \"onCreated\", \"onPointerMissed\"]);\n\n  const containerRef = useRef();\n  const [events, setEvents] = useState({});\n  const [bind, size] = useMeasure(resize || {\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    polyfill: typeof window === 'undefined' || !window.ResizeObserver ? ResizeObserver : undefined\n  }); // Flag view ready once it's been measured out\n\n  const readyFlag = useRef(false);\n  const ready = useMemo(() => readyFlag.current = readyFlag.current || !!size.width && !!size.height, [size]);\n  const state = useMemo(() => ({\n    size,\n    setEvents,\n    container: containerRef.current\n  }), [size]); // Allow Gatsby, Next and other server side apps to run. Will output styles to reduce flickering.\n\n  if (typeof window === 'undefined') return React__default.createElement(\"div\", {\n    style: _extends({}, defaultStyles, {}, style)\n  }); // Render the canvas into the dom\n\n  return React__default.createElement(\"div\", _extends({\n    ref: mergeRefs([bind, containerRef]),\n    style: _extends({}, defaultStyles, {}, style)\n  }, events, restSpread), preRender, ready && React__default.createElement(Content, _extends({}, props, state)));\n});\nconst Canvas = React__default.memo(_ref => {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  const canvasRef = useRef();\n  return React__default.createElement(ResizeContainer, _extends({}, props, {\n    renderer: () => {\n      if (canvasRef.current) {\n        const params = _extends({\n          antialias: true,\n          alpha: true\n        }, props.gl);\n\n        const temp = new WebGLRenderer(_extends({\n          canvas: canvasRef.current,\n          context: props.gl2 ? canvasRef.current.getContext('webgl2', params) : undefined\n        }, params));\n        return temp;\n      }\n    },\n    preRender: React__default.createElement(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        display: 'block'\n      }\n    })\n  }), children);\n});\nexport { Canvas, Dom, Renderer, addEffect, applyProps, createPortal, extend, invalidate, isOrthographicCamera, render, renderGl, stateContext, unmountComponentAtNode, useCamera, useCanvas, useFrame, useLoader, useResource, useThree, useUpdate };","map":null,"metadata":{},"sourceType":"module"}