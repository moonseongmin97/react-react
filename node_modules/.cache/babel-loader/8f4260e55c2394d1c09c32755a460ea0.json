{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasUtils = void 0;\n\nconst ColorUtils_1 = require(\"./ColorUtils\");\n\nconst NumberUtils_1 = require(\"./NumberUtils\");\n\nfunction drawLine(context, begin, end) {\n  context.beginPath();\n  context.moveTo(begin.x, begin.y);\n  context.lineTo(end.x, end.y);\n  context.closePath();\n}\n\nfunction drawTriangle(context, p1, p2, p3) {\n  context.beginPath();\n  context.moveTo(p1.x, p1.y);\n  context.lineTo(p2.x, p2.y);\n  context.lineTo(p3.x, p3.y);\n  context.closePath();\n}\n\nclass CanvasUtils {\n  static paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n  }\n\n  static clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n  }\n\n  static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n    let drawn = false;\n\n    if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n      drawLine(context, begin, end);\n      drawn = true;\n    } else if (warp) {\n      let pi1;\n      let pi2;\n      const endNE = {\n        x: end.x - canvasSize.width,\n        y: end.y\n      };\n      const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n\n      if (d1.distance <= maxDistance) {\n        const yi = begin.y - d1.dy / d1.dx * begin.x;\n        pi1 = {\n          x: 0,\n          y: yi\n        };\n        pi2 = {\n          x: canvasSize.width,\n          y: yi\n        };\n      } else {\n        const endSW = {\n          x: end.x,\n          y: end.y - canvasSize.height\n        };\n        const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n\n        if (d2.distance <= maxDistance) {\n          const yi = begin.y - d2.dy / d2.dx * begin.x;\n          const xi = -yi / (d2.dy / d2.dx);\n          pi1 = {\n            x: xi,\n            y: 0\n          };\n          pi2 = {\n            x: xi,\n            y: canvasSize.height\n          };\n        } else {\n          const endSE = {\n            x: end.x - canvasSize.width,\n            y: end.y - canvasSize.height\n          };\n          const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n\n          if (d3.distance <= maxDistance) {\n            const yi = begin.y - d3.dy / d3.dx * begin.x;\n            const xi = -yi / (d3.dy / d3.dx);\n            pi1 = {\n              x: xi,\n              y: yi\n            };\n            pi2 = {\n              x: pi1.x + canvasSize.width,\n              y: pi1.y + canvasSize.height\n            };\n          }\n        }\n      }\n\n      if (pi1 && pi2) {\n        drawLine(context, begin, pi1);\n        drawLine(context, end, pi2);\n        drawn = true;\n      }\n    }\n\n    if (!drawn) {\n      return;\n    }\n\n    context.lineWidth = width;\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n\n    if (shadow.enable) {\n      const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n\n      if (shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      }\n    }\n\n    context.stroke();\n  }\n\n  static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n    drawTriangle(context, pos1, pos2, pos3);\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n    context.fill();\n  }\n\n  static drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n  }\n\n  static gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n    const color1 = p1.getFillColor();\n    const color2 = p2.getFillColor();\n\n    if (!color1 || !color2) {\n      return;\n    }\n\n    const sourcePos = p1.getPosition();\n    const destPos = p2.getPosition();\n    const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n    const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n    return grad;\n  }\n\n  static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    drawLine(context, begin, end);\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n  }\n\n  static drawLight(container, context, mousePos) {\n    const lightOptions = container.options.interactivity.modes.light.area;\n    context.beginPath();\n    context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n    const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n    const gradient = lightOptions.gradient;\n    const gradientRgb = {\n      start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n      stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop)\n    };\n\n    if (!gradientRgb.start || !gradientRgb.stop) {\n      return;\n    }\n\n    gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n    gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n    context.fillStyle = gradientAmbientLight;\n    context.fill();\n  }\n\n  static drawParticleShadow(container, context, particle, mousePos) {\n    const pos = particle.getPosition();\n    const shadowOptions = container.options.interactivity.modes.light.shadow;\n    context.save();\n    const radius = particle.getRadius();\n    const sides = particle.sides;\n    const full = Math.PI * 2 / sides;\n    const angle = -particle.rotate.value + Math.PI / 4;\n    const factor = 1;\n    const dots = [];\n\n    for (let i = 0; i < sides; i++) {\n      dots.push({\n        x: pos.x + radius * Math.sin(angle + full * i) * factor,\n        y: pos.y + radius * Math.cos(angle + full * i) * factor\n      });\n    }\n\n    const points = [];\n    const shadowLength = shadowOptions.length;\n\n    for (const dot of dots) {\n      const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n      const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);\n      const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);\n      points.push({\n        endX: endX,\n        endY: endY,\n        startX: dot.x,\n        startY: dot.y\n      });\n    }\n\n    const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n\n    if (!shadowRgb) {\n      return;\n    }\n\n    const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n\n    for (let i = points.length - 1; i >= 0; i--) {\n      const n = i == points.length - 1 ? 0 : i + 1;\n      context.beginPath();\n      context.moveTo(points[i].startX, points[i].startY);\n      context.lineTo(points[n].startX, points[n].startY);\n      context.lineTo(points[n].endX, points[n].endY);\n      context.lineTo(points[i].endX, points[i].endY);\n      context.fillStyle = shadowColor;\n      context.fill();\n    }\n\n    context.restore();\n  }\n\n  static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n    const pos = particle.getPosition();\n    context.save();\n    context.translate(pos.x, pos.y);\n    context.beginPath();\n    const angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n\n    if (angle !== 0) {\n      context.rotate(angle);\n    }\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    const shadowColor = particle.shadowColor;\n\n    if (shadow.enable && shadowColor) {\n      context.shadowBlur = shadow.blur;\n      context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      context.shadowOffsetX = shadow.offset.x;\n      context.shadowOffsetY = shadow.offset.y;\n    }\n\n    if (fillColorValue) {\n      context.fillStyle = fillColorValue;\n    }\n\n    const stroke = particle.stroke;\n    context.lineWidth = particle.strokeWidth;\n\n    if (strokeColorValue) {\n      context.strokeStyle = strokeColorValue;\n    }\n\n    CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n\n    if (stroke.width > 0) {\n      context.stroke();\n    }\n\n    if (particle.close) {\n      context.closePath();\n    }\n\n    if (particle.fill) {\n      context.fill();\n    }\n\n    context.restore();\n    context.save();\n    context.translate(pos.x, pos.y);\n\n    if (angle !== 0) {\n      context.rotate(angle);\n    }\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n\n    CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n  }\n\n  static drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n\n    const drawer = container.drawers.get(particle.shape);\n\n    if (!drawer) {\n      return;\n    }\n\n    drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n  }\n\n  static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n\n    const drawer = container.drawers.get(particle.shape);\n\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n      return;\n    }\n\n    drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n  }\n\n  static drawPlugin(context, plugin, delta) {\n    if (plugin.draw !== undefined) {\n      context.save();\n      plugin.draw(context, delta);\n      context.restore();\n    }\n  }\n\n}\n\nexports.CanvasUtils = CanvasUtils;","map":null,"metadata":{},"sourceType":"script"}